#!/usr/bin/perl

use strict;

use Cwd qw(getcwd abs_path);
use File::Path qw(make_path);
use IO::Socket::INET;
use threads;
use threads::shared;
use Getopt::Long;
use File::Basename qw(dirname);

my $__scriptdir;
BEGIN { $__scriptdir = dirname(abs_path($0)); }
use lib $__scriptdir;
use rxplib::config qw(readconfig);
use rxplib::logging qw(verbose setverbose printmsg);
use rxplib::jobs qw(runjob);
use rxplib::net qw(recvlong);

$| = 1;

# Protocol version
my $PROTOCOL_VERSION = 1.1;

# Check arguments and set default paths
my $maxjobs = undef;
my $qmanager = undef;
my $serveraddress = undef;
my $serverport = undef;
my $hostname = undef;

GetOptions(
	'connect|c=s'	=> \$qmanager,
	'host|h=s'	=> \$hostname,
	'verbose|v'	=> sub { setverbose(1); },
);

# One bare options for the number of jobs is required
$maxjobs = shift @ARGV;
die "Extra arguments: " . join(' ', @ARGV) . "\n" if @ARGV;

if (defined $qmanager) {
	die "Invalid connection info '$qmanager'\n" unless $qmanager =~ /^[^:]+(:\d+)?$/;
	$qmanager =~ /^([^:]+)(:\d+)?$/;
	$serveraddress = $1; 
	$serverport = $2 if defined $2; 
	$serverport =~ s/^:// if defined $serverport;
}

die "Expected number of maximum jobs for this client\n" unless defined $maxjobs;
die "Invalid number of jobs: $maxjobs\n" unless $maxjobs =~ /^[0-9]+$/ && $maxjobs > 0;

# Read configurations from file
my %conf = readconfig();
for my $key (keys %conf) {
	if ($key eq "port" && !defined $serverport) {
		$serverport = $conf{$key};
		print "Using port $serverport as specified from config file\n";
	}
	elsif ($key eq "qmanager" && !defined $serveraddress) {
		$serveraddress = $conf{$key};
		print "Using server address $serveraddress as specified from config file\n";
	}
	elsif ($key eq "hostname" && !defined $hostname) {
		$hostname = $conf{$key};
		print "Using hostname $hostname as specified from config file\n";
	}
}

($hostname = `hostname -s`, chomp $hostname) unless defined $hostname;
die "Can't handle this hostname: '$hostname'\n" unless $hostname =~ /^[-_a-zA-Z0-9]+$/;

# The commbusy flag is used to indicate that a thread is trying to communicate with the server. We
# lock this variable because otherwise we would have to lock $masterstop and $serversocket
my $commbusy :shared = 0;

# If the shared variable masterstop is set to 1, then all workers will cease requesting new jobs
my $masterstop :shared = 0;

# Try to connect to and hail the server
verbose "Connecting to server at $serveraddress:$serverport";
my $serversocket = IO::Socket::INET->new(
	PeerAddr => $serveraddress,
	PeerPort => $serverport,
	Proto    => 'tcp',
) or die "Error connecting to server at $serveraddress:$serverport: $!\n";
hail_server($serversocket);

# Create workers and wait for them to finish
my @workers;
for my $i (1 .. $maxjobs) {
	my $worker = threads->create(\&workerloop, $i, $serversocket);
	push @workers, $worker;
}
for my $worker (@workers) {
	$worker->join();
}

# When we have finished, properly end communications
bye_server($serversocket);
$serversocket->close();
print "Done!\n";



###################



sub workerloop {
	my $id = shift;
	my $serversocket = shift;
	my $joboutcome;
	my $joboutput;

	verbose "Worker $id started";

	while (1) {
		my ($job, $jobtype, $jobdata);
		(verbose "Worker $id: finished" and return) unless askforjob($id, $serversocket, \$job, \$jobtype, \$jobdata);
		verbose "Worker $id: got a new job -- $job";
		($joboutcome, $joboutput) = runjob($hostname, $job, $jobtype, $jobdata);
		sendjoboutcome($id, $serversocket, $job, $joboutcome, $joboutput);
	}
}


# Tell the manager that a job has been complete and if it was successful
sub sendjoboutcome {
	my $id = shift;
	my $serversocket = shift;
	my $job = shift;
	my $outcome = shift;
	my $output = shift;

	my $outputlen = length $output;
	my $msg = "REZULTO $job $outcome $outputlen";
	
	verbose "Worker $id: [sendjoboutcome] trying to get lock of communications";
	lock $commbusy;
	verbose "Worker $id: [sendjoboutcome] I have the lock";

	verbose "Worker $id: sending message '$msg'";
	$serversocket->send($msg);

	verbose "Worker $id: waiting for server acknowledgement";
	$serversocket->recv($msg, 1024);
	die "Unexpected message received: $msg\n" unless $msg eq "PRETA";

	verbose "Worker $id: sending job outout ($outputlen bytes)";
	$serversocket->send($output);

	verbose "Worker $id: waiting for server acknowledgement";
	$serversocket->recv($msg, 1024);
	die "Unexpected message received: $msg\n" unless $msg eq "RICEVIS";

	verbose "Worker $id: [sendjoboutcome] relinquishing lock";
}


# Ask server for job
sub askforjob {
	my $id = shift;
	my $serversocket = shift;
	my $jobname = shift;
	my $jobtype = shift;
	my $jobdata = shift;

	my $msg;

	# Lock the communication flag
	verbose "Worker $id: [askforjob] trying to get lock of communications";
	lock($commbusy);
	verbose "Worker $id: [askforjob] I have the lock";

	# If another worker received a FINO message, then there are no more jobs
	(verbose "Worker $id: MASTERSTOP raised" and return 0) if $masterstop;

	verbose "Worker $id: sending server the message 'PETO'";
	$serversocket->send('PETO');

	verbose "Worker $id: waiting for job from the server";
	$serversocket->recv($msg, 1024);
	verbose "Worker $id: received message '$msg'";

	if ($msg eq "FINO") {
		verbose "Worker $id: no more jobs; raising MASTERSTOP";
		$masterstop = 1;
		return 0;
	}

	$msg =~ /^LABORO (.+) (\.[^ ]+) (\d+)$/ or die "Worker $id: Unexpected message $msg";
	$$jobname = $1;
	$$jobtype = $2;
	my $jobsize = $3;

	verbose "Worker $id: asking for job data ($jobsize bytes)";
	$serversocket->send("PRETA");

	verbose "Worker $id: waiting job data ($jobsize bytes)";
	$$jobdata = recvlong($serversocket, $jobsize);

	verbose "Worker $id: [askforjob] relinquishing lock";
	return 1;
}


# Handshake server: this is executed before workers are created, so there is no
# need to lock anything
sub hail_server {
	my $serversocket = shift;

	verbose "Sending server the 'SALUTON' hail";
	$serversocket->send("SALUTON; MI $hostname");

	verbose "Waiting for protocol version";
	my $msg;
	$serversocket->recv($msg, 1024);
	verbose "Received version string '$msg'";
	die "Bad protocol version: '$msg'\n" unless $msg =~ /^VERSIO \d+(.\d+)?$/;
	$msg =~ s/^VERSIO //;
	die "Bad protocol version: '$msg'\n" unless $msg eq "1.1";

	verbose "Version accepted. Sending server acknowledgement message";
	$serversocket->send("KOMPRENAS");
}


# Finish conversation with server
sub bye_server {
	my $serversocket = shift;

	verbose "Sending server the 'FINO ANKAU' message";
	$serversocket->send("FINO ANKAU");
}

__END__
=head1 NAME

experiment runner

=head1 SYNOPSIS
	
  runex <MAXJOBS> [<BASEDIR>] [OPTIONS]

This is the experiment runner for runexp. runexp is a system designed to launch
experiments in several experiment servers using a distributed file system as
communication medium.

Options:

	<MAXJOBS>  Mandatory argument that specifies how many experiments should
	           be simultaneously in execution at a time. This argument must
		   be specified before <BASEDIR>, if <BASEDIR> is specified.
	<BASEDIR>  Specify where runexp should look for the jobs and  outputs
		   directory. If ommitted, the current working directory is
		   used. This does not change the current working directory.
	-c, --connect <SERVER>:<PORT>
		   Specify that the queue manager is located on host <SERVER>
		   at port <PORT> (e.g.: localhost:5432)
	-r, --run <RUNPATH>
		   Specify the directory where jobs should be looked for. Each
		   job either a .m or a .sh file. The default value for this
		   option is <BASEDIR>/runs.
	-o, --output <OUTPUTPATH>
		   Specify the directory where the job outputs will be written.
		   When executed, the standard output and the standard error
		   output will be redicted to a file in this directory. The
		   default value for this option is <BASEDIR>/outputs.
	-h, --host <NAME>
		   Use <NAME> as hostname instead of system name.
	-v         Print detailed information.

runexp is hosted at GitHub. For source code and more information on how to use
runexp, please visit github.com/rfgiusti/runexp
