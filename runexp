#!/bin/bash

HOST=$(hostname -s)
SLEEPTIME=1
VERBOSE=1

if [[ -f ~/.runexp.conf ]]; then
	OLDHOST=$HOST
	source ~/.runexp.conf
	[[ "$OLDHOST" != "$HOST" ]] && echo "Hostname changed to '$HOST' by ~/.runexp.conf"
fi

MAXRUNNERS=$1
if [[ "$MAXRUNNERS" == "" ]]; then
	echo "Expected maximum number of jobs for this client"
	exit
fi
if [[ ! $MAXRUNNERS -gt 0 ]]; then
	echo "Number of runners \"$MAXRUNNERS\" is invalid"
	exit;
fi

mypath=`pwd -P`
runpath="$mypath/runs"
outpath="$mypath/outputs"

if [[ "$2" != "" ]]; then
	echo "Overriding runs path to $mypath/$2"
	runpath="$mypath/$2"
fi
if [[ "$3" != "" ]]; then
	echo "Overriding output path to $mypath/$3"
	outpath="$mypath/$3"
fi

if [[ ! -d "$runpath" ]]; then
	echo "Can't find run path '$runpath'"
	exit
fi
if [[ ! -d "$outpath" ]]; then
	echo "Can't find output path '$outpath'"
	exit
fi

maxfile="$mypath/$HOST.maxrunners"

# Keep track of jobs, one at a time
pids=()
jobnames=()
startimes=()
runningjobs=0

verbose() {
	if [[ "$VERBOSE" == "1" ]]; then
		echo "`date` -- [$HOST] INFO: $1"
	fi
}
verbose "Running in verbose mode"

isover() {
	if [[ -f "$runpath/master.stop" ]]; then
		return 0;
	else
		return 1;
	fi
}

writerunninginfo() {
	infofile="$runpath/$HOST.info"
	echo -n > $infofile
	i=0
	while [[ $i -lt $runningjobs ]]; do
		echo ${jobnames[$i]} >> $infofile
		echo ${starttimes[$i]} >> $infofile
		i=$(( $i + 1 ))
	done
	sync
}

addjob() {
	pids[$runningjobs]=$1
	jobnames[$runningjobs]=$2
	starttimes[$runningjobs]=$( date +%s )
	verbose "Now tracking job with PID ${pids[$runningjobs]} (${jobnames[$runningjobs]})"
	runningjobs=$(( $runningjobs + 1 ))
}

updaterunningjobs() {
	from=0
	to=0
	removed=0
	# Walk through list with two pointers, skipping jobs that are done
	# Array never decreases, but it will always be very small
	while [[ $from -lt $runningjobs ]]; do
		if [[ ! -d /proc/${pids[$from]} ]]; then
			from=$(( $from + 1 ))
			removed=$(( $removed + 1 ))
			verbose "Job with PID ${pids[$from]} (${jobnames[$from]}) is over"
		fi
		if [[ $from != $to ]]; then
			pids[$to]=${pids[$from]}
			jobnames[$to]=${jobnames[$from]}
			starttimes[$to]=${starttimes[$from]}
		fi
		from=$(( $from + 1 ))
		to=$(( $to + 1 ))
	done
	if [[ $removed > 0 ]]; then
		runningjobs=$(( $runningjobs - $removed ))
		writerunninginfo
	fi
}

echo "I am the experiment runner in $HOST and I'm here to run your jobs"
rm -f "$runpath/$HOST.req"
rm -f "$runpath/$HOST.go"
rm -f "$runpath/$HOST.info"
rm -f "$runpath/$HOST.ready"
verbose "Control files '$runpath/$HOST.{req,go,info}' removed"

while true; do
	# Check if there is room for more jobs
	while [[ $runningjobs -ge $MAXRUNNERS ]]; do
		if [[ -f "$maxfile" ]]; then
			newmax=`cat "$maxfile"`
			if [[ $newmax -gt 0 ]]; then
				echo "`date` -- [$HOST] Maximum runners updated from $MAXRUNNERS to $newmax"
				MAXRUNNERS=$newmax
				rm "$maxfile"
			else
				echo "`date` -- [$HOST] Maximum runners found, but content is invalid:"
				cat "$maxfile"
			fi		
		fi
		updaterunningjobs
		sleep $SLEEPTIME
	done

	# Quit if no more jobs to run are available
	isover && break

	# Request some jobs
	requestsize=$(( $MAXRUNNERS - $runningjobs ))
	verbose "Preparing to request up to $requestsize job(s)"
	
	# TODO: remove this ugly workaround
	while [[ -f "$runpath/$HOST.req" ]]; do
		# Request file should have been removed by the experiment
		# runner. Why am I still seeing it?
		verbose "File '$HOST.req' should not exist, but has been found. Waiting..."
		sleep 1;
	done
	echo $requestsize > "$runpath/$HOST.req"
	verbose "Written request file '$HOST.req' for up to $requestsize job(s)"

	# Attempt to ensure the file is written
	# TODO: check for race condition here
	# TODO: remove this ugly workaround
	sync
	while [[ -f "$runpath/$HOST.ready" ]]; do
		verbose "Flag file '$HOST.ready' should not exist, but has been found. Waiting..."
		sleep 1;
	done
	echo > "$runpath/$HOST.ready"
	verbose "Written flag file '$HOST.ready'"

	# Wait for permission to go, unless the server suddenly finds out there are no more jobs to run
	verbose "Waiting for manager finish writing the job list"
	while [[ ! -f "$runpath/$HOST.go" ]]; do
		sleep 1
		isover && break
	done
	if [[ ! -f "$runpath/$HOST.go" ]]; then
		echo "`date` -- [$HOST] Scratch that. There are no more jobs to run"
		break
	fi

	# Run the received jobs
	verbose "Checking job(s) from manager"
	for job in `cat "$runpath/$HOST.job"`; do
		jobname=`echo -n $job | sed 's!^.*/!!' | sed 's!\.[^.]*$!!'`
		echo "`date` -- [$HOST] Running $jobname"

		outfile="$outpath/$jobname.res"
		jobfile="$runpath/$job"
		verbose "Got a job to run:"
		verbose "   name: $jobname"
		verbose "   file: $jobfile"
		verbose "   output: $outfile"

		echo "`date` [$HOST] -- running $jobname" &> "$outfile"
		echo "" &>> "$outfile"

		jobtype=`echo -n $job | sed 's!^.*\.!!'`
		if [[ "$jobtype" == "m" ]]; then
			verbose "Running MATLAB with command line: 'matlab -singleCompThread -nodesktop -r \"addpath('$runpath'); $jobname; quit;\" &>> \"$outfile\" & disown -h"
			matlab -singleCompThread -nodesktop -r "addpath('$runpath'); $jobname; quit;" &>> "$outfile" & disown -h
			pid=$!
			addjob $pid "$jobname"
		elif [[ "$jobtype" == "sh" ]]; then
			verbose "Running bash script with command line: bash \"$jobfile\" &>> \"$outfile\" & disown -h"
			bash "$jobfile" &>> "$outfile" & disown -h
			pid=$!
			addjob $pid "$jobname"
		else
			echo "Invalid job type ($jobtype)"
		fi
	done

	writerunninginfo

	# Remove the job files
	rm "$runpath/$HOST.go"
	rm "$runpath/$HOST.job"
	vebose "Removed control files '$HOST.go' and '$HOST.job'"
done

updaterunningjobs
if [[ $runningjobs > 0 ]]; then
	echo "`date` -- [$HOST] All spawned. Waiting..."
	while [[ $runningjobs > 0 ]]; do
		sleep $SLEEPTIME
		updaterunningjobs
	done
fi
echo "`date` -- [$HOST] My work here is done."
