#!/usr/bin/perl

use strict;

use Cwd qw(getcwd abs_path);
use File::Path qw(make_path);
use IO::Socket::INET;
use threads;
use threads::shared;
use rxplib::config qw(readconfig);
use Getopt::Long;

$| = 1;

# Protocol version
my $PROTOCOL_VERSION = 1.0;

# Print detailed information if running verbosely
my $verbose :shared = 0;
sub verbose {
	return 1 unless $verbose;

	lock($verbose);
	my $msg = shift;
	
	my $time = `date "+%b %d %T"`;
	chomp $time;

	printf "$time [ INFO ] $msg\n";

	return 1;
}

# Check arguments and set default paths
my $maxjobs = undef;
my $runsubpath = 'runs';
my $outsubpath = 'outputs';
my $basedir = undef;
my $qmanager = undef;
my $serveraddress = undef;
my $serverport = undef;
my $hostname = undef;
my $path;

GetOptions(
	'runs|r=s'	=> \$runsubpath,
	'outputs|o=s'	=> \$outsubpath,
	'connect|c=s'	=> \$qmanager,
	'host|h=s'	=> \$hostname,
);

# Two bare options are accepted: number of jobs and base dir, in that order
$maxjobs = shift @ARGV;
$basedir = shift @ARGV;
die "Extra arguments: " . join(' ', @ARGV) . "\n" if @ARGV;

if (defined $qmanager) {
	die "Invalid connection info '$qmanager'\n" unless $qmanager =~ /^[^:]+(:\d+)?$/;
	$qmanager =~ /^([^:]+)(:\d+)?$/;
	$serveraddress = $1; 
	$serverport = $2 if defined $2; 
	$serverport =~ s/^:// if defined $serverport;
}

if (defined $basedir) {
	print "Overriding base directory from './' with '$basedir'\n";
	$path = abs_path($basedir);
}
else {
	$path = abs_path(getcwd());
}
$path =~ s{/$}{};
my $runpath = "$path/$runsubpath";
my $outpath = "$path/$outsubpath";
$runpath =~ s{/$}{};
$outpath =~ s{/$}{};

die "Expected number of maximum jobs for this client\n" unless defined $maxjobs;
die "Invalid number of jobs: $maxjobs\n" unless $maxjobs =~ /^[0-9]+$/ && $maxjobs > 0;

die "Can't find runs directory at $runpath\n" unless -d $runpath;
die "Can't find outputs directory at $outpath\n" unless -d $outpath;

# Read configurations from file
my %conf = readconfig();
for my $key (keys %conf) {
	if ($key eq "port" && !defined $serverport) {
		$serverport = $conf{$key};
		print "Using port $serverport as specified from config file\n";
	}
	elsif ($key eq "qmanager" && !defined $serveraddress) {
		$serveraddress = $conf{$key};
		print "Using server address $serveraddress as specified from config file\n";
	}
	elsif ($key eq "hostname" && !defined $hostname) {
		$hostname = $conf{$key};
		print "Using hostname $hostname as specified from config file\n";
	}
}

($hostname = `hostname -s`, chomp $hostname) unless defined $hostname;
die "Can't handle this hostname: '$hostname'\n" unless $hostname =~ /^[-_a-zA-Z0-9]+$/;

# The commbusy flag is used to indicate that a thread is trying to communicate with the server. We
# lock this variable because otherwise we would have to lock $masterstop and $serversocket
my $commbusy :shared = 0;

# If the shared variable masterstop is set to 1, then all workers will cease requesting new jobs
my $masterstop :shared = 0;

# Try to connect to and hail the server
verbose "Connecting to server at $serveraddress:$serverport";
my $serversocket = IO::Socket::INET->new(
	PeerAddr => $serveraddress,
	PeerPort => $serverport,
	Proto    => 'tcp',
) or die "Error connecting to server at $serveraddress:$serverport: $!\n";
hail_server($serversocket);

# Create workers and wait for them to finish
my @workers;
for my $i (1 .. $maxjobs) {
	my $worker = threads->create(\&workerloop, $i, $serversocket);
	push @workers, $worker;
}
print "No more new jobs to run. Waiting for current jobs to finish...\n";
for my $worker (@workers) {
	$worker->join();
}

# When we have finished, properly end communications
bye_server($serversocket);
$serversocket->close();
print "Done!\n";



###################



sub workerloop {
	my $id = shift;
	my $serversocket = shift;

	verbose "Worker $id started";

	while (1) {
		my $job = askforjob($id, $serversocket);
		(verbose "Worker $id: finished" and return) unless defined $job;
		verbose "Worker $id: got a new job -- $job";
		runjob($job);
	}
}


# Print information before running a job
sub printrun {
        my $jobname = shift;

        my $time = `date "+%b %d %T"`;
        chomp $time;

        printf "$time [$hostname] Running $jobname\n";
}


# Print a fail log
sub printfail {
	my $failmessage = shift;
        
	my $time = `date "+%b %d %T"`;
        chomp $time;

        printf "$time [$hostname] ERROR: $failmessage\n";
}


sub runandlog {
	my $longname = shift;
	my $cmdline = shift;
	my $output = shift;

	printrun($longname);

	verbose "Job info";
	verbose "  name   : $longname";
	verbose "  output : $output";
	verbose "  cmdline: $cmdline";

	my $starttime = `date`;
	chomp $starttime;
	verbose "Running job $longname";
	my $progoutput = `$cmdline`;
	my $progstatus = $?;
	verbose "Finished job $longname";
	my $endtime = `date`;
	chomp $endtime;

	open OUTPUT, ">$output" or die "Error opening $output";
	print OUTPUT "$starttime -- [$hostname] Running $longname\n";
	print OUTPUT "> $cmdline\n";
	print OUTPUT "$endtime -- Finished running\n";
	print OUTPUT "Program exited with status $progstatus\n";
	print OUTPUT "Program output follows\n";
	print OUTPUT "\n";
	print OUTPUT $progoutput;
	close OUTPUT;
}

# Run a MATLAB job
sub runmatlab {
	my $longname = shift;
	my $shortname = shift;
	my $jobdir = shift;
	my $output = shift;

	if (-f "$shortname.m") {
		printfail "A script named '$shortname.m' in the current working dir causes conflict";
		return;
	}

	print "<<";
	my $matlabcmd ="try; $shortname; catch e, fprintf('Failed: %s\\n', e.message); end";
	my $cmdline = "matlab -singleCompThread -nodisplay -nodesktop -nosplash -r \"addpath('$jobdir'); $matlabcmd; quit;\"";
	print ">>\n";
	runandlog($longname, $cmdline, $output);
}


# Run a bash job
sub runbash {
	my $longname = shift;
	my $job = shift;
	my $output = shift;

	my $cmdline = "bash '$job'";
	runandlog($longname, $cmdline, $output);
}


# Run a new job
sub runjob {
	my $job = shift;

	# Separate /path/runs/subpath/job.ext into long name (subpath/job) and shortname (job)
	$job =~ m{^$runpath/(.+)} or die "Can't match job '$job' against m{^$runpath/(.+)}";
	my $longname = $1;
	$longname =~ s{\.[^.]+$}{};
	my $shortname = $longname;
	$shortname =~ s{(.*/)?([^/]+)}{$2};

	# Compose the output file path
	my $output = "$outpath/$longname.res";

	# Get the job directory (full path)
	my $jobdir = $job;
	$jobdir =~ s{(.*/)[^/]+}{$1};

	# If the job has an extension, use it as job type
	my $type = $job =~ /\.[^.]+/ ? $& : '';

	# Write the output file preamble


	if ($type eq ".m") {
		runmatlab($longname, $shortname, $jobdir, $output);
	}
	elsif ($type eq ".sh") {
		runbash($longname, $job, $output);
	}
	else {
		printfail("Invalid job type '$type'");
	}
}


# Ask server for job
sub askforjob {
	my $id = shift;
	my $serversocket = shift;
	my $reqsize = 1;
	my $msg;

	# Lock the communication flag
	verbose "Worker $id: trying to get lock of communications";
	lock($commbusy);
	verbose "Worker $id: I have the lock";

	# If another worker received a FINO message, then there are no more jobs
	(verbose "Worker $id: MASTERSTOP raised" and return undef) if $masterstop;

	verbose "Worker $id: sending server the message 'PETO'";
	$serversocket->send('PETO');

	verbose "Worker $id: waiting for job from the server";
	$serversocket->recv($msg, 1024);
	verbose "Worker $id: received message '$msg'";

	if ($msg eq "FINO") {
		verbose "Worker $id: raising MASTERSTOP";
		$masterstop = 1;
		return undef;
	}
	return "$runpath/$msg";
}


# Handshake server: this is executed before workers are created, so there is no
# need to lock anything
sub hail_server {
	my $serversocket = shift;

	verbose "Sending server the 'SALUTON' hail";
	$serversocket->send("SALUTON; MI $hostname");

	verbose "Waiting for protocol version";
	my $msg;
	$serversocket->recv($msg, 1024);
	verbose "Received version string '$msg'";
	die "Bad protocol version: $msg\n" unless $msg =~ /^VERSIO \d+(.\d+)?$/;
	$msg =~ s/^VERSIO //;
	die "Bad protocol version: $msg\n" unless $msg == 1.0;

	verbose "Version accepted. Sending server acknowledgement message";
	$serversocket->send("KOMPRENAS");
}


# Finish conversation with server
sub bye_server {
	my $serversocket = shift;

	verbose "Sending server the 'KOMPRENAS' message";
	$serversocket->send("KOMPRENAS");
}

__END__
=head1 NAME

experiment runner

=head1 SYNOPSIS
	
  runex <MAXJOBS> [<BASEDIR>] [OPTIONS]

This is the experiment runner for runexp. runexp is a system designed to launch
experiments in several experiment servers using a distributed file system as
communication medium.

Options:

	<MAXJOBS>  Mandatory argument that specifies how many experiments should
	           be simultaneously in execution at a time. This argument must
		   be specified before <BASEDIR>, if <BASEDIR> is specified.
	<BASEDIR>  Specify where runexp should look for the jobs and  outputs
		   directory. If ommitted, the current working directory is
		   used. This does not change the current working directory.
	-c, --connect <SERVER>:<PORT>
		   Specify that the queue manager is located on host <SERVER>
		   at port <PORT> (e.g.: localhost:5432)
	-r, --run <RUNPATH>
		   Specify the directory where jobs should be looked for. Each
		   job either a .m or a .sh file. The default value for this
		   option is <BASEDIR>/runs.
	-o, --output <OUTPUTPATH>
		   Specify the directory where the job outputs will be written.
		   When executed, the standard output and the standard error
		   output will be redicted to a file in this directory. The
		   default value for this option is <BASEDIR>/outputs.
	-h, --host <NAME>
		   Use <NAME> as hostname instead of system name.
	-v         Print detailed information.

runexp is hosted at GitHub. For source code and more information on how to use
runexp, please visit github.com/rfgiusti/runexp
