#!/usr/bin/perl

use strict;

use Cwd qw(getcwd abs_path);
use File::Path qw(make_path);
use IO::Socket::INET;
use threads;
use threads::shared;
use Getopt::Long;
use File::Basename qw(dirname);

my $__scriptdir;
BEGIN { $__scriptdir = dirname(abs_path($0)); }
use lib $__scriptdir;
use rxplib::config qw(readconfig);
use rxplib::logging qw(verbose setverbose printmsg);
use rxplib::jobs qw(runjob);

$| = 1;

# Protocol version
my $PROTOCOL_VERSION = 1.0;


# Check arguments and set default paths
my $maxjobs = undef;
my $runsubpath = 'runs';
my $outsubpath = 'outputs';
my $basedir = undef;
my $qmanager = undef;
my $serveraddress = undef;
my $serverport = undef;
my $hostname = undef;
my $path;

GetOptions(
	'runs|r=s'	=> \$runsubpath,
	'outputs|o=s'	=> \$outsubpath,
	'connect|c=s'	=> \$qmanager,
	'host|h=s'	=> \$hostname,
	'verbose|v'	=> sub { setverbose(1); },
);

# Two bare options are accepted: number of jobs and base dir, in that order
$maxjobs = shift @ARGV;
$basedir = shift @ARGV;
die "Extra arguments: " . join(' ', @ARGV) . "\n" if @ARGV;

if (defined $qmanager) {
	die "Invalid connection info '$qmanager'\n" unless $qmanager =~ /^[^:]+(:\d+)?$/;
	$qmanager =~ /^([^:]+)(:\d+)?$/;
	$serveraddress = $1; 
	$serverport = $2 if defined $2; 
	$serverport =~ s/^:// if defined $serverport;
}

if (defined $basedir) {
	print "Overriding base directory from './' with '$basedir'\n";
	$path = abs_path($basedir);
}
else {
	$path = abs_path(getcwd());
}
$path =~ s{/$}{};
my $runpath = "$path/$runsubpath";
my $outpath = "$path/$outsubpath";
$runpath =~ s{/$}{};
$outpath =~ s{/$}{};

die "Expected number of maximum jobs for this client\n" unless defined $maxjobs;
die "Invalid number of jobs: $maxjobs\n" unless $maxjobs =~ /^[0-9]+$/ && $maxjobs > 0;

die "Can't find runs directory at $runpath\n" unless -d $runpath;
die "Can't find outputs directory at $outpath\n" unless -d $outpath;

# Read configurations from file
my %conf = readconfig();
for my $key (keys %conf) {
	if ($key eq "port" && !defined $serverport) {
		$serverport = $conf{$key};
		print "Using port $serverport as specified from config file\n";
	}
	elsif ($key eq "qmanager" && !defined $serveraddress) {
		$serveraddress = $conf{$key};
		print "Using server address $serveraddress as specified from config file\n";
	}
	elsif ($key eq "hostname" && !defined $hostname) {
		$hostname = $conf{$key};
		print "Using hostname $hostname as specified from config file\n";
	}
}

($hostname = `hostname -s`, chomp $hostname) unless defined $hostname;
die "Can't handle this hostname: '$hostname'\n" unless $hostname =~ /^[-_a-zA-Z0-9]+$/;

# The commbusy flag is used to indicate that a thread is trying to communicate with the server. We
# lock this variable because otherwise we would have to lock $masterstop and $serversocket
my $commbusy :shared = 0;

# If the shared variable masterstop is set to 1, then all workers will cease requesting new jobs
my $masterstop :shared = 0;

# Try to connect to and hail the server
verbose "Connecting to server at $serveraddress:$serverport";
my $serversocket = IO::Socket::INET->new(
	PeerAddr => $serveraddress,
	PeerPort => $serverport,
	Proto    => 'tcp',
) or die "Error connecting to server at $serveraddress:$serverport: $!\n";
hail_server($serversocket);

# Create workers and wait for them to finish
my @workers;
for my $i (1 .. $maxjobs) {
	my $worker = threads->create(\&workerloop, $i, $serversocket);
	push @workers, $worker;
}
print "No more new jobs to run. Waiting for current jobs to finish...\n";
for my $worker (@workers) {
	$worker->join();
}

# When we have finished, properly end communications
bye_server($serversocket);
$serversocket->close();
print "Done!\n";



###################



sub workerloop {
	my $id = shift;
	my $serversocket = shift;

	verbose "Worker $id started";

	while (1) {
		my $job = askforjob($id, $serversocket);
		(verbose "Worker $id: finished" and return) unless defined $job;
		verbose "Worker $id: got a new job -- $job";
		runjob($hostname, $runpath, $outpath, $job);
	}
}



# Ask server for job
sub askforjob {
	my $id = shift;
	my $serversocket = shift;
	my $reqsize = 1;
	my $msg;

	# Lock the communication flag
	verbose "Worker $id: trying to get lock of communications";
	lock($commbusy);
	verbose "Worker $id: I have the lock";

	# If another worker received a FINO message, then there are no more jobs
	(verbose "Worker $id: MASTERSTOP raised" and return undef) if $masterstop;

	verbose "Worker $id: sending server the message 'PETO'";
	$serversocket->send('PETO');

	verbose "Worker $id: waiting for job from the server";
	$serversocket->recv($msg, 1024);
	verbose "Worker $id: received message '$msg'";

	if ($msg eq "FINO") {
		verbose "Worker $id: raising MASTERSTOP";
		$masterstop = 1;
		return undef;
	}
	return "$runpath/$msg";
}


# Handshake server: this is executed before workers are created, so there is no
# need to lock anything
sub hail_server {
	my $serversocket = shift;

	verbose "Sending server the 'SALUTON' hail";
	$serversocket->send("SALUTON; MI $hostname");

	verbose "Waiting for protocol version";
	my $msg;
	$serversocket->recv($msg, 1024);
	verbose "Received version string '$msg'";
	die "Bad protocol version: $msg\n" unless $msg =~ /^VERSIO \d+(.\d+)?$/;
	$msg =~ s/^VERSIO //;
	die "Bad protocol version: $msg\n" unless $msg == 1.0;

	verbose "Version accepted. Sending server acknowledgement message";
	$serversocket->send("KOMPRENAS");
}


# Finish conversation with server
sub bye_server {
	my $serversocket = shift;

	verbose "Sending server the 'KOMPRENAS' message";
	$serversocket->send("KOMPRENAS");
}

__END__
=head1 NAME

experiment runner

=head1 SYNOPSIS
	
  runex <MAXJOBS> [<BASEDIR>] [OPTIONS]

This is the experiment runner for runexp. runexp is a system designed to launch
experiments in several experiment servers using a distributed file system as
communication medium.

Options:

	<MAXJOBS>  Mandatory argument that specifies how many experiments should
	           be simultaneously in execution at a time. This argument must
		   be specified before <BASEDIR>, if <BASEDIR> is specified.
	<BASEDIR>  Specify where runexp should look for the jobs and  outputs
		   directory. If ommitted, the current working directory is
		   used. This does not change the current working directory.
	-c, --connect <SERVER>:<PORT>
		   Specify that the queue manager is located on host <SERVER>
		   at port <PORT> (e.g.: localhost:5432)
	-r, --run <RUNPATH>
		   Specify the directory where jobs should be looked for. Each
		   job either a .m or a .sh file. The default value for this
		   option is <BASEDIR>/runs.
	-o, --output <OUTPUTPATH>
		   Specify the directory where the job outputs will be written.
		   When executed, the standard output and the standard error
		   output will be redicted to a file in this directory. The
		   default value for this option is <BASEDIR>/outputs.
	-h, --host <NAME>
		   Use <NAME> as hostname instead of system name.
	-v         Print detailed information.

runexp is hosted at GitHub. For source code and more information on how to use
runexp, please visit github.com/rfgiusti/runexp
