#!/usr/bin/perl

use strict;

use Cwd qw(getcwd abs_path);
use File::Path qw(make_path);
use IO::Socket::INET;
use IO::Select;
use threads;
use threads::shared;
use Thread::Queue;
use Getopt::Long qw(:config no_ignore_case bundling auto_help);
use File::Basename qw(dirname);

my $__scriptdir;
BEGIN { $__scriptdir = dirname(abs_path($0)); }
use lib $__scriptdir;
use rxplib::config qw(readconfig);
use rxplib::jobs qw(donejob getjobname);
use rxplib::logging qw(verbose setverbose printpct);

$| = 1;

# Communication protocol version
my $PROTOCOL_VERSION = 1.0;

# Check arguments and set default paths
my $runsubpath = 'runs';
my $outsubpath = 'outputs';
my $printjobs = 0;
my $randomize = 0;
my $basedir = undef;
my $stopparsing = 0;
my $port = undef;

GetOptions(
	'runs|r=s'	=> \$runsubpath,
	'outputs|o=s'	=> \$outsubpath,
	'print-jobs'	=> \$printjobs,
	'random'	=> \$randomize,
	'port|p=n'	=> \$port,
	'verbose|v'	=> sub { setverbose(1); },
) or die "Executiong terminated.\n";

# Only one bare argument is accepted: the base dir
$basedir = shift @ARGV;
die "Extra arguments: " . join(' ', @ARGV) . "\n" if @ARGV;


my $path;
if (defined $basedir) {
	$path = abs_path($basedir);
}
else {
	$path = abs_path(getcwd());
}
$path =~ s{/$}{};
my $runpath = "$path/$runsubpath";
my $outpath = "$path/$outsubpath";
$runpath =~ s{/$}{};
$outpath =~ s{/$}{};

die "Runs directory not found in $runpath\n" unless -d $runpath;

# Check if the configuration file has options that we need checking
my %conf = readconfig();
for my $key (keys %conf) {
	if ($key eq "port" && !defined $port) {
		$port = $conf{port};
		print "Using port $port as specified from config file\n";
	}
}

die "No port to listen to specified\n" unless defined $port;

# Search for jobs in the runpath and its sub directories, checks if all required directories
# exist in the ouput path as well
my @tree = gettree($runpath, 'm|sh');
my @jobs = ();
for my $subdir (@tree) {
	# Remove the run path from the directory name, search for the required directory in
	# the outputs dir
	my $outputdir = $subdir;
	$outputdir =~ s{^$runpath}{$outpath};
	if (! -d $outputdir) {
		my $errors;
		make_path($outputdir, {verbose => 0, error => \$errors});
		if (@$errors) {
			die "Attempt to create directory and parent directories $outputdir failed:\n" .
				join("\n", @$errors) . "\n";
		}
		print "Created output directory (and possibly parent directories) $outputdir\n";
	}
	push @jobs, getfiles($subdir, 'm|sh');
}
die "There are no jobs here.\n" unless scalar(@jobs);

my $totaljobs :shared = scalar(@jobs);
my $ranjobs :shared = 0;
print "There are $totaljobs jobs here.\n";

@jobs = grep(!donejob($_, $runpath, $outpath), @jobs);
$ranjobs = $totaljobs - @jobs;
if (!@jobs) {
	print "I have already run everything. Nothing else to do here.\n";
	exit;
}
elsif ($ranjobs) {
	printf "I have already run $ranjobs job%s. I will skip them.\n", ($ranjobs > 1 ? "s" : "");
	printf "I now have " . (scalar @jobs) . " job%s to run.\n", (@jobs > 1 ? "s" : "");
}
else {
	print "I did not do anything yet.\n";
}

# Job list may or may not be sorted. Do not assume anything. Unless option --randomize is supplied,
# then the list should be sorted.
if ($randomize) {
	randomizejobs(\@jobs) if $randomize;
}
else {
	@jobs = sort { $a cmp $b } @jobs;
}

if ($printjobs) {
	print join("\n", @jobs) . "\n";
	exit 0;
}

verbose "Opening server at port $port";
my $serversocket = IO::Socket::INET->new(
	LocalHost => '0.0.0.0',
	LocalPort => $port,
	Proto     => 'tcp',
	Listen    => 5,
	ReuseAddr => 1,
) or die "Error opening server on port $port: $!\n";
my $select = IO::Select->new($serversocket);

my $jobqueue = makejobqueue(\@jobs);
my $runningthreads :shared = 0;
my @sockets;
while ($jobqueue->pending()) {
	my @ready = $select->can_read(1);
	if (scalar (@ready)) {
		my $client = $serversocket->accept();
		my $remoteaddr = $client->peerhost();
		my $remoteport = $client->peerport();
		my $clientid = scalar @sockets;
		verbose "Accepted client #$clientid from $remoteaddr:$remoteport";

		{
			lock($runningthreads);
			$runningthreads++;
			verbose "Running threads: $runningthreads";
		}
		threads->create(\&clientloop, $client, $clientid)->detach();
		push @sockets, $client;
	}
}
print "All jobs were spawned.\n";
print "Waiting for clients to disconnect.\n";
while ($runningthreads) {
	verbose "Running threads: $runningthreads";
	sleep 1;
}
print "Done!\n";

for my $socket (@sockets) {
	$socket->close();
}
$serversocket->close();


################


# Return the job list in a thread-safe job queue
sub makejobqueue {
	my $jobs = shift;
	my $queue = Thread::Queue->new;

	for my $job (@$jobs) {
		$queue->enqueue($job);
	}
	$queue->end();

	return $queue;
}


# Get all files with extension specified by $ext in the specified directory. $ext is a pipe-separated list
sub getfiles {
	my $dir = shift;
	my $ext = shift;
	
	opendir(RUNS, $dir) or die "Can't open runs directory at $dir\n";
	my @files = map "$dir/$_", grep(/\.($ext)$/, readdir(RUNS));
	closedir(RUNS);

	return @files;
}

# Get the directories that have job files
sub gettree {
	my $root = shift;
	my $ext = shift;
	my @result = ();

	opendir CHILDREN, $root or die "Can't open directory at $root\n";
	my @children = readdir(CHILDREN);
	closedir CHILDREN;

	my @dirs = grep(-d "$root/$_" && !m/^\.\.?$/, @children);
	my @jobs = grep(-f "$root/$_" && m/\.($ext)$/, @children);

	for my $subdir (@dirs) {
		my @subresult = gettree("$root/$subdir", $ext);
		if (scalar(@subresult) > 0) {
			push @result, @subresult;
		}
	}
	if (scalar(@jobs)) {
		push @result, $root;
	}

	return @result;
}

sub randomizejobs {
	my $list = shift;
	my $numjobs = scalar (@$list);
	my $numshuffled = 0;

	while ($numshuffled < $numjobs) {
		# Randomly selects a job from the non-shuffled block
		my $pick = int(rand($numjobs - $numshuffled));

		# Moves to the end of the non-shuffled block, which will be the first new shuffled job
		$numshuffled++;
		my $moveto = $numjobs - $numshuffled;
		my $aux = $list->[$moveto];
		$list->[$moveto] = $list->[$pick];
		$list->[$pick] = $aux;
	}
}


# Receive the SALUTON message from the client and get client's name
sub client_hail {
	my $socket = shift;
	my $id = shift;
	my $msg;

	# Wait for cleint to send the HELLO message
	verbose "Client $id: waiting 'SALUTON'";
	$socket->recv($msg, 1024);
	verbose "Client $id: received message '$msg'";
	return undef unless $msg =~ /^SALUTON; MI ([-_a-zA-Z0-9]+)$/;
	my $name = $1;
	verbose "Client $id: now known as $name";

	# Send protocol version to client
	verbose "Client $name: sending 'VERSIO'";
	$socket->send(sprintf("VERSIO %.1f", $PROTOCOL_VERSION));	

	# Wait for client to acknowledge
	verbose "Client $name: waiting 'KOMPRENAS'";
	$socket->recv($msg, 1024);
	return undef unless $msg eq "KOMPRENAS";

	return $name;
}


# Wait for a client to send a request for jobs
sub client_readjobrequest {
	my $socket = shift;
	my $name = shift;
	my $msg;

	verbose "Client $name: waiting for job request";
	$socket->recv($msg, 1024);

	verbose "Cliend $name: received message '$msg'";
	return $msg eq "PETO";
}



# Send a job to the client
sub client_sendjob {
	my $socket = shift;
	my $name = shift;
	my $job = shift;

	my $jobname = $job;
	$jobname =~ s{^$runpath/}{};

	verbose "Client $name: sending job";
	$socket->send($jobname);
}


# Send FINO message to client and receives their acknowledgement
sub client_bye {
	my $socket = shift;
	my $name = shift;

	verbose "Client $name: no more jobs to run";
	verbose "Client $name: sending FINO message";
	$socket->send('FINO');

	verbose "Client $name: waiting for acknowledgment";
	my $msg;
	$socket->recv($msg, 1024);
	verbose "Client $name: received '$msg'";
	return $msg eq "KOMPRENAS";
}


# Should be called before a thread is finished
sub endthread {
	lock($runningthreads);
	$runningthreads--;
	return 1;
}


sub clientloop {
	my $socket = shift;
	my $id = shift;
	my $name = shift;

	my $name = client_hail($socket, $id);
	(endthread and return) unless defined $name;

	while (1) {
		(endthread and return) unless client_readjobrequest($socket, $name);
		
		verbose "Client $name: requested a job";
		my $nextjob = getnextjob();
		last unless defined $nextjob;

		client_sendjob($socket, $name, $nextjob);
		{
			lock $ranjobs;
			$ranjobs++;
			printpct($name, 100 * ($ranjobs / $totaljobs), getjobname($nextjob));
		}
	}

	client_bye($socket, $name);
	endthread;
}


# Return the next undone job
sub getnextjob {
	while ($jobqueue->pending()) {
		my $candidate = $jobqueue->dequeue();
		return $candidate unless donejob($candidate, $runpath, $outpath);
	}
	return undef;
}

__END__
=head1 NAME

queueexp - queue experiments for distributed execution

=head1 SYNOPSIS

queueexp [<BASEDIR>] [OPTIONS]

This is the queue management for runexp. runexp is a system designed to launch
experiments in several experiment servers using a distributed file system as
communication medium.

Options:
	
	<BASEDIR>  Specify where runexp should look for the jobs and  outputs
		   directory. If ommitted, the current working directory is
		   used. This does not change the current working directory.
	-r,--run <RUNPATH>
		   Specify the directory where jobs should be looked for. Each
		   job either a .m or a .sh file. The default value for this
		   option is <BASEDIR>/runs
	-o,--output <OUTPUTPATH>
		   Specify the directory where the job outputs will be written.
		   When executed, the standard output and the standard error
		   output will be redicted to a file in this directory. The
		   default value for this option is <BASEDIR>/outputs
	--random   Run jobs in random order instead of lexicographical order.
	--print-jobs
		   Print remaining jobs and quit.
	-v         Print detailed information.
	-p <PORT>  Listen on port <PORT>
	
runexp is hosted at GitHub. For source code and more information on how to use
runexp, please visit github.com/rfgiusti/runexp
