#!/usr/bin/perl

use strict;

use Cwd qw(getcwd abs_path);
use File::Path qw(make_path);
use IO::Socket::INET;
use threads;
use threads::shared;

# Communication protocol version
my $PROTOCOL_VERSION = 1.0;

# Print detailed information if running verbosely
my $verbose = 0;
sub verbose {
	return unless $verbose;

	my $msg = shift;
	
	my $time = `date "+%b %d %T"`;
	chomp $time;

	printf "$time [ INFO ] $msg\n";
}

# Check arguments and set default paths
my $runsubpath = 'runs';		# default jobs directory
my $outsubpath = 'outputs';		# default outputs directory
my $printjobs = 0;
my $randomize = 0;			# randomize jobs
my $basedir = undef;
my $stopparsing = 0;
my $port = undef;
my @args = @ARGV;
while (@args) {
	my $arg = shift @args;

	if ($stopparsing) {
		# A previous -- was supplied. So no more arguments should be parsed. The only valid option
		# is the basedir. And it must be defined only once.
		die "Invalid argument '$arg'\n" if defined $basedir;
		$basedir = $arg;
		next;
	}
	
	if ($arg eq "-r") {
		my $next = shift @args;
		die "Missing value for option -r\n" unless defined $next;
		print "Overriding runs directory from '$runsubpath' with '$next'\n";
		$runsubpath = $next;
	}
	elsif ($arg eq "-o") {
		my $next = shift @args;
		die "Missing value for option -o\n" unless defined $next;
		print "Overriding output directory from '$outsubpath' with '$next'\n";
		$outsubpath = $next;
	}
	elsif ($arg eq "-v") {
		$verbose = 1;
		verbose "Entered VERBOSE mode.";
	}
	elsif ($arg eq "--print-jobs") {
		$printjobs = 1;
	}
	elsif ($arg eq "--random") {
		$randomize = 1;
	}
	elsif ($arg eq "-p") {
		my $next = shift @args;
		die "Missing value for option -p\n" unless defined $next;
		$port = $next;
		die "Invalid port number: $port\n" unless $port =~ /^[0-9]+$/;
	}
	elsif ($arg eq "--help") {
		my $me = $0 || "queueexp";
		$me =~ s!.*/!!;
		print "$me: queue experiments for distributed execution

This is the queue management for runexp. runexp is a system designed to launch
experiments in several experiment servers using a distributed file system as
communication medium.

Usage:
	$me [<BASEDIR>] [OPTIONS]

	<BASEDIR>  Specify where runexp should look for the jobs and  outputs
		   directory. If ommitted, the current working directory is
		   used. This does not change the current working directory.
	-r <RUNPATH>
		   Specify the directory where jobs should be looked for. Each
		   job either a .m or a .sh file. The default value for this
		   option is <BASEDIR>/runs
	-o <OUTPUTPATH>
		   Specify the directory where the job outputs will be written.
		   When executed, the standard output and the standard error
		   output will be redicted to a file in this directory. The
		   default value for this option is <BASEDIR>/outputs
	--random   Run jobs in random order instead of lexicographical order.
	--print-jobs
		   Print remaining jobs and quit.
	-v         Print detailed information.
	-p <PORT>  Listen on port <PORT>
	
This is a 'works-for-me' kind of system. It works for me, right now, and that's
currently enough. If it doesn't work for you, that could be because you're not
me, or maybe you are me in a distant future and you don't remember why you even
needed this in the first place.

You're currently using an SSH filesystem to establish the distributed file
system that runexp requires. Go to the experiment server, sshfs to your machine
and symlink whatever you need. The experiment server should not know it's not
your workstation.

Once the experiment server is set up, launch the queue manager in your
workstation, then launch the runners in each experiment server. It should go
like this:

	\$ queueexp -r runs -o logs
	\$ ssh user\@experimentserver
	[...]
	\$ runexp 8 runs logs

This will run 8 simultaneous jobs in the experiment server.
";
		exit;
	}
	elsif ($arg eq "--") {
		# Stop parsing arguments
		$stopparsing = 1;
	}
	elsif ($arg !~ /^-/) {
		# If something that does not start with a dash is supplied, we assume it is the base
		# directory. Unless it has already been supplied.
		die "Invalid argument '$arg'\n" if defined $basedir;
		$basedir = $arg;
		print "Overriding base directory from './' with '$basedir'\n";
	}
	else {
		die "Invalid argument '$arg'\n";
	}
}
my $path;
if (defined $basedir) {
	$path = abs_path($basedir);
}
else {
	$path = abs_path(getcwd());
}
$path =~ s{/$}{};
my $runpath = "$path/$runsubpath";
my $outpath = "$path/$outsubpath";
my $donetest = "$outpath/runtest.exp";   # optional external program to check if an experiment was run

die "Run test program exists, but is not executable.\n" if -f $donetest && ! -x $donetest;

die "No port to listen to specified\n" unless defined $port;
die "Runs directory not found in $runpath\n" unless -d $runpath;

# Search for jobs in the runpath and its sub directories, checks if all required directories
# exist in the ouput path as well
my @tree = gettree($runpath, 'm|sh');
my @jobs = ();
for my $subdir (@tree) {
	# Remove the run path from the directory name, search for the required directory in
	# the outputs dir
	my $outputdir = $subdir;
	$outputdir =~ s{^$runpath/?}{$outpath/};
	if (! -d $outputdir) {
		my $errors;
		make_path($outputdir, {verbose => 0, error => \$errors});
		if (@$errors) {
			die "Attempt to create directory and parent directories $outputdir failed:\n" .
				join("\n", @$errors) . "\n";
		}
		print "Created output directory (and possibly parent directories) $outputdir\n";
	}
	push @jobs, getfiles($subdir, 'm|sh');
}
die "There are no jobs here.\n" unless scalar(@jobs);

my $totaljobs = @jobs;
my $ranjobs = 0;
print "There are $totaljobs jobs here.\n";

@jobs = grep(!donejob($_), @jobs);
my $ranjobs = $totaljobs - @jobs;
if (!@jobs) {
	print "I have already run everything. Nothing else to do here.\n";
	exit;
}
elsif ($ranjobs) {
	printf "I have already run $ranjobs job%s. I will skip them.\n", ($ranjobs > 1 ? "s" : "");
	printf "I now have " . (scalar @jobs) . " job%s to run.\n", (@jobs > 1 ? "s" : "");
}
else {
	print "I did not do anything yet.\n";
}

# Job list may or may not be sorted. Do not assume anything. Unless option --randomize is supplied,
# then the list should be sorted.
if ($randomize) {
	randomizejobs(\@jobs) if $randomize;
}
else {
	@jobs = sort { $a cmp $b } @jobs;
}

if ($printjobs) {
	print join("\n", @jobs) . "\n";
	exit 0;
}

verbose "Opening server at port $port";
my $serversocket = IO::Socket::INET->new(
	LocalHost => '0.0.0.0',
	LocalPort => $port,
	Proto     => 'tcp',
	Listen    => 5,
	ReuseAddr => 1,
) or die "Error opening server on port $port: $!\n";

my $runningthreads :shared = 0;
my @sockets;
while (1) {
	verbose "Waiting for connections";
	my $client = $serversocket->accept();
	my $remoteaddr = $client->peerhost();
	my $remoteport = $client->peerport();
	my $clientid = scalar @sockets;
	verbose "Accepted client #$clientid from $remoteaddr:$remoteport";

	{
		lock($runningthreads);
		$runningthreads++;
	}
	threads->create(\&clientloop, $client, $clientid)->detach();
	push @sockets, $client;
}
print "All jobs were spawned.\n";
print "Waiting for clients to disconnect.\n";
while ($runningthreads) {
	sleep 1;
}


################

# Get all files with extension specified by $ext in the specified directory. $ext is a pipe-separated list
sub getfiles {
	my $dir = shift;
	my $ext = shift;
	
	opendir(RUNS, $dir) or die "Can't open runs directory at $dir\n";
	my @files = map "$dir/$_", grep(/\.($ext)$/, readdir(RUNS));
	closedir(RUNS);

	return @files;
}

# Get the directories that have job files
sub gettree {
	my $root = shift;
	my $ext = shift;
	my @result = ();

	opendir CHILDREN, $root or die "Can't open directory at $root\n";
	my @children = readdir(CHILDREN);
	closedir CHILDREN;

	my @dirs = grep(-d "$root/$_" && !m/^\.\.?$/, @children);
	my @jobs = grep(-f "$root/$_" && m/\.($ext)$/, @children);

	for my $subdir (@dirs) {
		my @subresult = gettree("$root/$subdir", $ext);
		if (scalar(@subresult) > 0) {
			push @result, @subresult;
		}
	}
	if (scalar(@jobs)) {
		push @result, $root;
	}

	return @result;
}

# Print if request file is empty
sub printfail {
	my $host = shift;

	my $time = `date "+%b %d %T"`;
	chomp $time;

	printf "$time [ERROR] $host: request file is empty. Client is stuck\n";
}	


# Print information before running a job
sub printrun {
	my $ranpct = shift;
	my $jobname = shift;
	my $host = shift;

	my $time = `date "+%b %d %T"`;
	chomp $time;

	printf "$time [%5.1f%%] $host: $jobname\n", 100 * $ranpct;
}


# Check if a job has already been executed. A job has been executed if its output file contains the string RES: or if
# a verification application returns 1
sub donejob {
	my $jobfile = shift;
	verbose "Checking if job '$jobfile' is done";

	my $resfile = $jobfile;
	$resfile =~ s{^$runpath/}{$outpath/};
	$resfile =~ s{\.[^.]*$}{.res};
	verbose "Searching output file '$resfile'";
	
	if (-f $donetest) {
		#	`'$donetest' '$jobname' '$jobfile' '$resfile'`;
		die "FEATURE REMOVED";
		return $?;
	}

	return 0 unless -f $resfile;

	my $done = 0;
	open OUTFILE, "<$resfile";
	while (my $line = <OUTFILE>) {
		if ($line =~ /RES:/ && $line !~ /RES:\s*fail/) {
			$done = 1;
			last;
		}
	}
	close OUTFILE;

	return $done;
}


sub randomizejobs {
	my $list = shift;
	my $numjobs = scalar (@$list);
	my $numshuffled = 0;

	while ($numshuffled < $numjobs) {
		# Randomly selects a job from the non-shuffled block
		my $pick = int(rand($numjobs - $numshuffled));

		# Moves to the end of the non-shuffled block, which will be the first new shuffled job
		$numshuffled++;
		my $moveto = $numjobs - $numshuffled;
		my $aux = $list->[$moveto];
		$list->[$moveto] = $list->[$pick];
		$list->[$pick] = $aux;
	}
}


# Receive the SALUTON message from the client and 
sub client_hail {
	my $socket = shift;
	my $id = shift;
	my $msg;

	# Wait for cleint to send the HELLO message
	verbose "Client $id: waiting 'SALUTON'";
	$socket->recv($msg, 1024);
	return 0 unless $msg eq "SALUTON";

	# Send protocol version to client
	verbose "Client $id: sending 'VERSIO'";
	$socket->send(sprintf("VERSIO %.1f", $PROTOCOL_VERSION));	

	# Wait for client to acknowledge
	verbose "Client $id: waiting 'KOMPRENAS'";
	$socket->recv($msg, 1024);
	return 0 unless $msg eq "KOMPRENAS";

	return 1;
}


# Should be called before a thread is finished
sub endthread {
	lock($runningthreads);
	$runningthreads--;
	return 1;
}


sub clientloop {
	my $socket = shift;
	my $id = shift;

	(endthread and return) unless client_hail($socket, $id);
	print "Client accepted connection\n";

	endthread;
}
